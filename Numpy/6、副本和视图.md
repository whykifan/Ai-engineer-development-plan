
<!-- TOC -->

- [NumPy 副本和视图](#numpy-副本和视图)
    - [1、完全不复制](#1完全不复制)
    - [2、视图或浅复制](#2视图或浅复制)
    - [3、副本或深拷贝](#3副本或深拷贝)

<!-- /TOC -->

# NumPy 副本和视图
当计算和操作数组时，它们的数据有时被复制到新的数组中，有时不复制。这里我们做个区分。

**副本是一个数据的完整的拷贝，如果我们对副本进行修改，它不会影响到原始数据，物理内存不在同一位置。**

**视图是数据的一个别称或引用，通过该别称或引用亦便可访问、操作原有数据，但原有数据不会产生拷贝。如果我们对视图进行修改，它会影响到原始数据，物理内存在同一位置。**

**视图一般发生在：**

-   1、numpy 的切片操作返回原数据的视图。
-   2、调用 ndarray 的 view() 函数产生一个视图。

**副本一般发生在：**

-   Python 序列的切片操作，调用deepCopy()函数。
-   调用 ndarray 的 copy() 函数产生一个副本。

## 1、完全不复制
简单赋值不会创建数组对象或其数据的拷贝。
```python
a = np.arange(6)  
b = a 
id(a)
id(b) # id(a)和id(b)结果相同
b.shape =  3,2  
a.shape # 修改b形状，结果a的形状也变了
```
## 2、视图或浅复制

不同的数组对象可以共享相同的数据。**`view`方法创建一个新数组对象，该对象看到相同的数据**。与前一种情况不同， **新数组的维数更改不会更改原始数据的维数 ，但是新数组数据更改后，也会影响原始数据。**
```python
>>> c = a.view()  
>>> c is a  
False  
>>> c.base is a  
True  
>>> c.flags.owndata  
False  
>>> c.shape = 2,6  
>>> a.shape  
(3L, 4L)  
>>> c[0,4] = 1234  
>>> a  
array([[ 0, 1, 2, 3],  
[1234, 5, 6, 7],  
[ 8, 9, 10, 11]])
```
## 3、副本或深拷贝
ndarray.copy() 函数创建一个副本。 对副本数据进行修改，不会影响到原始数据，它们物理内存不在同一位置：
```python
>>> d = a.copy() # 一个完整的新的数组  
>>> d is a  
False  
>>> d.base is a  
False  
>>> d[0,0] = 9999  
>>> a # 修改数组 d 的值，a不会受影响  
array([[ 0, 10, 10, 3],  
[1234, 10, 10, 7],  
[ 8, 10, 10, 11]])
```
